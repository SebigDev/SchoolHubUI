/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    changePassword(email: string | null | undefined, oldPassword: string | null | undefined, newPassword: string | null | undefined): Observable<AuthResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Authentication/ChangePassword?";
        if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        if (oldPassword !== undefined)
            url_ += "oldPassword=" + encodeURIComponent("" + oldPassword) + "&"; 
        if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<AuthResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthResponse | null>(<any>null);
    }

    resetPassword(request: ResetPasswordRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Authentication/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ClassesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    createClass(createClassDto: CreateClassDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Classes/CreateClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createClassDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClass(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClass(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    assignClassToStaff(staffId: number | undefined, classId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Classes/AssignClassToStaff?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&"; 
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignClassToStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignClassToStaff(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAssignClassToStaff(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateClass(classDto: ClassDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Classes/UpdateClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClass(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateClass(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    deleteClass(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Classes/DeleteClass?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClass(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteClass(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    retrieveAssignedClassToStaff(staffId: number | undefined): Observable<StaffClassAssIgnedResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Classes/RetrieveAssignedClassToStaff?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAssignedClassToStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAssignedClassToStaff(<any>response_);
                } catch (e) {
                    return <Observable<StaffClassAssIgnedResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffClassAssIgnedResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAssignedClassToStaff(response: HttpResponseBase): Observable<StaffClassAssIgnedResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StaffClassAssIgnedResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffClassAssIgnedResponse | null>(<any>null);
    }

    retriveUnAssignedClasses(staffId: number | undefined): Observable<ClassDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Classes/RetriveUnAssignedClasses?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetriveUnAssignedClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetriveUnAssignedClasses(<any>response_);
                } catch (e) {
                    return <Observable<ClassDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetriveUnAssignedClasses(response: HttpResponseBase): Observable<ClassDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassDto[] | null>(<any>null);
    }

    retrieveClassById(id: number | undefined): Observable<ClassDto | null> {
        let url_ = this.baseUrl + "/api/v1/Classes/RetrieveClassById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveClassById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveClassById(<any>response_);
                } catch (e) {
                    return <Observable<ClassDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveClassById(response: HttpResponseBase): Observable<ClassDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassDto | null>(<any>null);
    }

    retrieveAllClasses(): Observable<ClassDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Classes/RetrieveAllClasses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllClasses(<any>response_);
                } catch (e) {
                    return <Observable<ClassDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAllClasses(response: HttpResponseBase): Observable<ClassDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassDto[] | null>(<any>null);
    }
}

@Injectable()
export class StaffsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    createStaff(model: CreateStaffDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Staffs/CreateStaff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStaff(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStaff(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    retrieveStaffById(staffId: number | undefined): Observable<StaffQualificationResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Staffs/RetrieveStaffById?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveStaffById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveStaffById(<any>response_);
                } catch (e) {
                    return <Observable<StaffQualificationResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffQualificationResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveStaffById(response: HttpResponseBase): Observable<StaffQualificationResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StaffQualificationResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffQualificationResponse | null>(<any>null);
    }

    retrieveStaffByUserId(userId: number | undefined): Observable<StaffQualificationResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Staffs/RetrieveStaffByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveStaffByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveStaffByUserId(<any>response_);
                } catch (e) {
                    return <Observable<StaffQualificationResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffQualificationResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveStaffByUserId(response: HttpResponseBase): Observable<StaffQualificationResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StaffQualificationResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffQualificationResponse | null>(<any>null);
    }

    retrieveStaffByStaffByUserType(userType: number | undefined): Observable<StaffDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Staffs/RetrieveStaffByStaffByUserType?";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "userType=" + encodeURIComponent("" + userType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveStaffByStaffByUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveStaffByStaffByUserType(<any>response_);
                } catch (e) {
                    return <Observable<StaffDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveStaffByStaffByUserType(response: HttpResponseBase): Observable<StaffDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaffDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffDto[] | null>(<any>null);
    }

    retrieveAllStaffs(): Observable<StaffDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Staffs/RetrieveAllStaffs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllStaffs(<any>response_);
                } catch (e) {
                    return <Observable<StaffDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAllStaffs(response: HttpResponseBase): Observable<StaffDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaffDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffDto[] | null>(<any>null);
    }

    getPhoto(staffId: number | undefined): Observable<string | null> {
        let url_ = this.baseUrl + "/api/v1/Staffs/GetPhoto?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhoto(<any>response_);
                } catch (e) {
                    return <Observable<string | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<string | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhoto(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string | null>(<any>null);
    }

    updateStaff(update: StaffDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Staffs/UpdateStaff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStaff(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStaff(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    addQualification(model: AddQualificationDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Staffs/AddQualification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddQualification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddQualification(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddQualification(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getQualificationsByStaffId(staffId: number | undefined): Observable<QualificationDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Staffs/GetQualificationsByStaffId?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQualificationsByStaffId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQualificationsByStaffId(<any>response_);
                } catch (e) {
                    return <Observable<QualificationDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<QualificationDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetQualificationsByStaffId(response: HttpResponseBase): Observable<QualificationDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QualificationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QualificationDto[] | null>(<any>null);
    }
}

@Injectable()
export class StudentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    createStudent(classId: number | undefined, createStudentDto: CreateStudentDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Students/CreateStudent?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createStudentDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStudent(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStudent(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    retrieveStudentsByClassId(classId: number | undefined): Observable<StudentClassResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Students/RetrieveStudentsByClassId?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveStudentsByClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveStudentsByClassId(<any>response_);
                } catch (e) {
                    return <Observable<StudentClassResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StudentClassResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveStudentsByClassId(response: HttpResponseBase): Observable<StudentClassResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StudentClassResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentClassResponse | null>(<any>null);
    }

    retrieveStudentsById(id: number | undefined): Observable<StudentDto | null> {
        let url_ = this.baseUrl + "/api/v1/Students/RetrieveStudentsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveStudentsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveStudentsById(<any>response_);
                } catch (e) {
                    return <Observable<StudentDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StudentDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveStudentsById(response: HttpResponseBase): Observable<StudentDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StudentDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentDto | null>(<any>null);
    }
}

@Injectable()
export class SubjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    createSubject(createSubjectDto: CreateSubjectDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Subjects/CreateSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createSubjectDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubject(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubject(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createClassSubject(classId: number | undefined, createSubjectDto: CreateSubjectDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Subjects/CreateClassSubject?";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createSubjectDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClassSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClassSubject(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClassSubject(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateSubject(subjectDto: SubjectDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Subjects/UpdateSubject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subjectDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubject(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    deleteSubject(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Subjects/DeleteSubject?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubject(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubject(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    retrieveSubjectById(id: number | undefined): Observable<SubjectDto | null> {
        let url_ = this.baseUrl + "/api/v1/Subjects/RetrieveSubjectById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveSubjectById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveSubjectById(<any>response_);
                } catch (e) {
                    return <Observable<SubjectDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubjectDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveSubjectById(response: HttpResponseBase): Observable<SubjectDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubjectDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectDto | null>(<any>null);
    }

    retrieveAllSubjectsByStudentId(id: number | undefined): Observable<StudentSubjectsResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Subjects/RetrieveAllSubjectsByStudentId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllSubjectsByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllSubjectsByStudentId(<any>response_);
                } catch (e) {
                    return <Observable<StudentSubjectsResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StudentSubjectsResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAllSubjectsByStudentId(response: HttpResponseBase): Observable<StudentSubjectsResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StudentSubjectsResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentSubjectsResponse | null>(<any>null);
    }

    retrieveAllSubjects(): Observable<SubjectDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Subjects/RetrieveAllSubjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllSubjects(<any>response_);
                } catch (e) {
                    return <Observable<SubjectDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubjectDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAllSubjects(response: HttpResponseBase): Observable<SubjectDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubjectDto[] | null>(<any>null);
    }

    retrieveAllSubjectsByClassId(id: number | undefined): Observable<ClassSubjectResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Subjects/RetrieveAllSubjectsByClassId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllSubjectsByClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllSubjectsByClassId(<any>response_);
                } catch (e) {
                    return <Observable<ClassSubjectResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassSubjectResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAllSubjectsByClassId(response: HttpResponseBase): Observable<ClassSubjectResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassSubjectResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassSubjectResponse | null>(<any>null);
    }
}

@Injectable()
export class UsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    register(model: CreateUserDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Users/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    login(username: string | null | undefined, email: string | null | undefined, password: string | null | undefined): Observable<UserLoginResponse | null> {
        let url_ = this.baseUrl + "/api/v1/Users/Login?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLoginResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<UserLoginResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginResponse.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginResponse | null>(<any>null);
    }

    updateUser(id: number | undefined, username: string | null | undefined, emailAddress: string | null | undefined, password: string | null | undefined, userType: number | undefined, isUpdated: boolean | undefined, isEmailConfirmed: boolean | undefined, updatedOn: Date | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Users/UpdateUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (username !== undefined)
            url_ += "Username=" + encodeURIComponent("" + username) + "&"; 
        if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&"; 
        if (password !== undefined)
            url_ += "Password=" + encodeURIComponent("" + password) + "&"; 
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&"; 
        if (isUpdated === null)
            throw new Error("The parameter 'isUpdated' cannot be null.");
        else if (isUpdated !== undefined)
            url_ += "IsUpdated=" + encodeURIComponent("" + isUpdated) + "&"; 
        if (isEmailConfirmed === null)
            throw new Error("The parameter 'isEmailConfirmed' cannot be null.");
        else if (isEmailConfirmed !== undefined)
            url_ += "IsEmailConfirmed=" + encodeURIComponent("" + isEmailConfirmed) + "&"; 
        if (updatedOn !== undefined)
            url_ += "UpdatedOn=" + encodeURIComponent(updatedOn ? "" + updatedOn.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    deleteUser(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Users/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    retrieveUserByEmail(email: string | null | undefined): Observable<UserDto | null> {
        let url_ = this.baseUrl + "/api/v1/Users/RetrieveUserByEmail?";
        if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveUserByEmail(<any>response_);
                } catch (e) {
                    return <Observable<UserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveUserByEmail(response: HttpResponseBase): Observable<UserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto | null>(<any>null);
    }

    retrieveUserById(id: number | undefined): Observable<UserDto | null> {
        let url_ = this.baseUrl + "/api/v1/Users/RetrieveUserById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveUserById(<any>response_);
                } catch (e) {
                    return <Observable<UserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveUserById(response: HttpResponseBase): Observable<UserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto | null>(<any>null);
    }

    retrieveAllUsers(): Observable<UserDto[] | null> {
        let url_ = this.baseUrl + "/api/v1/Users/RetrieveAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveAllUsers(response: HttpResponseBase): Observable<UserDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[] | null>(<any>null);
    }
}

export class AuthResponse implements IAuthResponse {
    status!: boolean;
    success?: string | undefined;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.success = data["success"];
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["success"] = this.success;
        return data; 
    }
}

export interface IAuthResponse {
    status: boolean;
    success?: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    password?: string | undefined;
    userId!: number;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IResetPasswordRequest {
    password?: string | undefined;
    userId: number;
}

export class CreateClassDto implements ICreateClassDto {
    classCode?: string | undefined;
    name?: string | undefined;
    category!: CategoryEnum;

    constructor(data?: ICreateClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classCode = data["classCode"];
            this.name = data["name"];
            this.category = data["category"];
        }
    }

    static fromJS(data: any): CreateClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classCode"] = this.classCode;
        data["name"] = this.name;
        data["category"] = this.category;
        return data; 
    }
}

export interface ICreateClassDto {
    classCode?: string | undefined;
    name?: string | undefined;
    category: CategoryEnum;
}

export enum CategoryEnum {
    Primary = 0, 
    Secondary = 1, 
}

export class ClassDto implements IClassDto {
    id!: number;
    classCode?: string | undefined;
    name?: string | undefined;
    createdOn?: Date | undefined;
    category?: string | undefined;

    constructor(data?: IClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.classCode = data["classCode"];
            this.name = data["name"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
            this.category = data["category"];
        }
    }

    static fromJS(data: any): ClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["classCode"] = this.classCode;
        data["name"] = this.name;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["category"] = this.category;
        return data; 
    }
}

export interface IClassDto {
    id: number;
    classCode?: string | undefined;
    name?: string | undefined;
    createdOn?: Date | undefined;
    category?: string | undefined;
}

export class StaffClassAssIgnedResponse implements IStaffClassAssIgnedResponse {
    staffId!: number;
    classes?: ClassDto[] | undefined;

    constructor(data?: IStaffClassAssIgnedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.staffId = data["staffId"];
            if (data["classes"] && data["classes"].constructor === Array) {
                this.classes = [] as any;
                for (let item of data["classes"])
                    this.classes!.push(ClassDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffClassAssIgnedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StaffClassAssIgnedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        if (this.classes && this.classes.constructor === Array) {
            data["classes"] = [];
            for (let item of this.classes)
                data["classes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStaffClassAssIgnedResponse {
    staffId: number;
    classes?: ClassDto[] | undefined;
}

export class CreateStaffDto implements ICreateStaffDto {
    userId!: number;
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    dateOfBirth!: Date;
    dateEmployed!: Date;
    gender!: GenderEnum;
    userType!: UserTypeEnum;
    photo?: string | undefined;

    constructor(data?: ICreateStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.firstname = data["firstname"];
            this.middlename = data["middlename"];
            this.lastname = data["lastname"];
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.dateEmployed = data["dateEmployed"] ? new Date(data["dateEmployed"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.userType = data["userType"];
            this.photo = data["photo"];
        }
    }

    static fromJS(data: any): CreateStaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstname"] = this.firstname;
        data["middlename"] = this.middlename;
        data["lastname"] = this.lastname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateEmployed"] = this.dateEmployed ? this.dateEmployed.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["userType"] = this.userType;
        data["photo"] = this.photo;
        return data; 
    }
}

export interface ICreateStaffDto {
    userId: number;
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    dateOfBirth: Date;
    dateEmployed: Date;
    gender: GenderEnum;
    userType: UserTypeEnum;
    photo?: string | undefined;
}

export enum GenderEnum {
    Male = 1, 
    Female = 2, 
}

export enum UserTypeEnum {
    Admin = 1, 
    Staff = 2, 
    Student = 3, 
}

export class StaffQualificationResponse implements IStaffQualificationResponse {
    staff?: StaffDto | undefined;
    qualification?: QualificationDto[] | undefined;

    constructor(data?: IStaffQualificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.staff = data["staff"] ? StaffDto.fromJS(data["staff"]) : <any>undefined;
            if (data["qualification"] && data["qualification"].constructor === Array) {
                this.qualification = [] as any;
                for (let item of data["qualification"])
                    this.qualification!.push(QualificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffQualificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StaffQualificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staff"] = this.staff ? this.staff.toJSON() : <any>undefined;
        if (this.qualification && this.qualification.constructor === Array) {
            data["qualification"] = [];
            for (let item of this.qualification)
                data["qualification"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStaffQualificationResponse {
    staff?: StaffDto | undefined;
    qualification?: QualificationDto[] | undefined;
}

export class StaffDto implements IStaffDto {
    id!: number;
    userId!: number;
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    age!: number;
    dateEmployed!: Date;
    isActive?: boolean | undefined;
    isUpdate!: boolean;
    gender?: string | undefined;
    dateOfRegistration!: Date;
    userType?: string | undefined;
    photo?: string | undefined;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.firstname = data["firstname"];
            this.middlename = data["middlename"];
            this.lastname = data["lastname"];
            this.age = data["age"];
            this.dateEmployed = data["dateEmployed"] ? new Date(data["dateEmployed"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isUpdate = data["isUpdate"];
            this.gender = data["gender"];
            this.dateOfRegistration = data["dateOfRegistration"] ? new Date(data["dateOfRegistration"].toString()) : <any>undefined;
            this.userType = data["userType"];
            this.photo = data["photo"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["firstname"] = this.firstname;
        data["middlename"] = this.middlename;
        data["lastname"] = this.lastname;
        data["age"] = this.age;
        data["dateEmployed"] = this.dateEmployed ? this.dateEmployed.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isUpdate"] = this.isUpdate;
        data["gender"] = this.gender;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["userType"] = this.userType;
        data["photo"] = this.photo;
        return data; 
    }
}

export interface IStaffDto {
    id: number;
    userId: number;
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    age: number;
    dateEmployed: Date;
    isActive?: boolean | undefined;
    isUpdate: boolean;
    gender?: string | undefined;
    dateOfRegistration: Date;
    userType?: string | undefined;
    photo?: string | undefined;
}

export class QualificationDto implements IQualificationDto {
    institution?: string | undefined;
    certficate?: string | undefined;
    dateObtained!: Date;
    staffId!: number;

    constructor(data?: IQualificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.institution = data["institution"];
            this.certficate = data["certficate"];
            this.dateObtained = data["dateObtained"] ? new Date(data["dateObtained"].toString()) : <any>undefined;
            this.staffId = data["staffId"];
        }
    }

    static fromJS(data: any): QualificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution;
        data["certficate"] = this.certficate;
        data["dateObtained"] = this.dateObtained ? this.dateObtained.toISOString() : <any>undefined;
        data["staffId"] = this.staffId;
        return data; 
    }
}

export interface IQualificationDto {
    institution?: string | undefined;
    certficate?: string | undefined;
    dateObtained: Date;
    staffId: number;
}

export class AddQualificationDto implements IAddQualificationDto {
    institution?: string | undefined;
    certficate?: string | undefined;
    dateObtained!: Date;

    constructor(data?: IAddQualificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.institution = data["institution"];
            this.certficate = data["certficate"];
            this.dateObtained = data["dateObtained"] ? new Date(data["dateObtained"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AddQualificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddQualificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution;
        data["certficate"] = this.certficate;
        data["dateObtained"] = this.dateObtained ? this.dateObtained.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAddQualificationDto {
    institution?: string | undefined;
    certficate?: string | undefined;
    dateObtained: Date;
}

export class CreateStudentDto implements ICreateStudentDto {
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    dateOfBirth!: Date;
    gender!: GenderEnum;
    dateOfRegistration!: Date;
    dateUpdated?: Date | undefined;

    constructor(data?: ICreateStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstname = data["firstname"];
            this.middlename = data["middlename"];
            this.lastname = data["lastname"];
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.dateOfRegistration = data["dateOfRegistration"] ? new Date(data["dateOfRegistration"].toString()) : <any>undefined;
            this.dateUpdated = data["dateUpdated"] ? new Date(data["dateUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["middlename"] = this.middlename;
        data["lastname"] = this.lastname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateStudentDto {
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    dateOfBirth: Date;
    gender: GenderEnum;
    dateOfRegistration: Date;
    dateUpdated?: Date | undefined;
}

export class StudentClassResponse implements IStudentClassResponse {
    classId!: number;
    students?: StudentDto[] | undefined;

    constructor(data?: IStudentClassResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classId = data["classId"];
            if (data["students"] && data["students"].constructor === Array) {
                this.students = [] as any;
                for (let item of data["students"])
                    this.students!.push(StudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentClassResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StudentClassResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        if (this.students && this.students.constructor === Array) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStudentClassResponse {
    classId: number;
    students?: StudentDto[] | undefined;
}

export class StudentDto implements IStudentDto {
    id!: number;
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    dateOfBirth!: Date;
    age!: number;
    isActive?: boolean | undefined;
    isUpdate!: boolean;
    gender?: string | undefined;
    dateOfRegistration!: Date;
    dateUpdated?: Date | undefined;

    constructor(data?: IStudentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstname = data["firstname"];
            this.middlename = data["middlename"];
            this.lastname = data["lastname"];
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.age = data["age"];
            this.isActive = data["isActive"];
            this.isUpdate = data["isUpdate"];
            this.gender = data["gender"];
            this.dateOfRegistration = data["dateOfRegistration"] ? new Date(data["dateOfRegistration"].toString()) : <any>undefined;
            this.dateUpdated = data["dateUpdated"] ? new Date(data["dateUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstname"] = this.firstname;
        data["middlename"] = this.middlename;
        data["lastname"] = this.lastname;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["isActive"] = this.isActive;
        data["isUpdate"] = this.isUpdate;
        data["gender"] = this.gender;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IStudentDto {
    id: number;
    firstname?: string | undefined;
    middlename?: string | undefined;
    lastname?: string | undefined;
    dateOfBirth: Date;
    age: number;
    isActive?: boolean | undefined;
    isUpdate: boolean;
    gender?: string | undefined;
    dateOfRegistration: Date;
    dateUpdated?: Date | undefined;
}

export class CreateSubjectDto implements ICreateSubjectDto {
    subjectCode?: string | undefined;
    subjectName?: string | undefined;
    createdOn?: Date | undefined;
    createdBy!: number;

    constructor(data?: ICreateSubjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subjectCode = data["subjectCode"];
            this.subjectName = data["subjectName"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
        }
    }

    static fromJS(data: any): CreateSubjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectCode"] = this.subjectCode;
        data["subjectName"] = this.subjectName;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data; 
    }
}

export interface ICreateSubjectDto {
    subjectCode?: string | undefined;
    subjectName?: string | undefined;
    createdOn?: Date | undefined;
    createdBy: number;
}

export class SubjectDto implements ISubjectDto {
    id!: number;
    subjectCode?: string | undefined;
    subjectName?: string | undefined;
    createdOn?: Date | undefined;
    createdBy!: number;

    constructor(data?: ISubjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.subjectCode = data["subjectCode"];
            this.subjectName = data["subjectName"];
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
        }
    }

    static fromJS(data: any): SubjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectCode"] = this.subjectCode;
        data["subjectName"] = this.subjectName;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data; 
    }
}

export interface ISubjectDto {
    id: number;
    subjectCode?: string | undefined;
    subjectName?: string | undefined;
    createdOn?: Date | undefined;
    createdBy: number;
}

export class StudentSubjectsResponse implements IStudentSubjectsResponse {
    studentId!: number;
    subjects?: SubjectDto[] | undefined;

    constructor(data?: IStudentSubjectsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.studentId = data["studentId"];
            if (data["subjects"] && data["subjects"].constructor === Array) {
                this.subjects = [] as any;
                for (let item of data["subjects"])
                    this.subjects!.push(SubjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentSubjectsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StudentSubjectsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        if (this.subjects && this.subjects.constructor === Array) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStudentSubjectsResponse {
    studentId: number;
    subjects?: SubjectDto[] | undefined;
}

export class ClassSubjectResponse implements IClassSubjectResponse {
    classId!: number;
    subjects?: SubjectDto[] | undefined;

    constructor(data?: IClassSubjectResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classId = data["classId"];
            if (data["subjects"] && data["subjects"].constructor === Array) {
                this.subjects = [] as any;
                for (let item of data["subjects"])
                    this.subjects!.push(SubjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassSubjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClassSubjectResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        if (this.subjects && this.subjects.constructor === Array) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClassSubjectResponse {
    classId: number;
    subjects?: SubjectDto[] | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    username?: string | undefined;
    emailAddress?: string | undefined;
    password?: string | undefined;
    isAdmin?: boolean | undefined;
    isEmailConfirmed?: boolean | undefined;
    userType!: UserTypeEnum;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.isAdmin = data["isAdmin"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.userType = data["userType"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["isAdmin"] = this.isAdmin;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["userType"] = this.userType;
        return data; 
    }
}

export interface ICreateUserDto {
    username?: string | undefined;
    emailAddress?: string | undefined;
    password?: string | undefined;
    isAdmin?: boolean | undefined;
    isEmailConfirmed?: boolean | undefined;
    userType: UserTypeEnum;
}

export class UserLoginResponse implements IUserLoginResponse {
    success!: boolean;
    token?: string | undefined;
    userId!: number;
    expiryDate!: Date;

    constructor(data?: IUserLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.token = data["token"];
            this.userId = data["userId"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginResponse {
    success: boolean;
    token?: string | undefined;
    userId: number;
    expiryDate: Date;
}

export class UserDto implements IUserDto {
    id!: number;
    username?: string | undefined;
    emailAddress?: string | undefined;
    isEmailConfirmed?: boolean | undefined;
    isAdmin?: boolean | undefined;
    isUpdated?: boolean | undefined;
    userType!: UserTypeEnum;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.username = data["username"];
            this.emailAddress = data["emailAddress"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isAdmin = data["isAdmin"];
            this.isUpdated = data["isUpdated"];
            this.userType = data["userType"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["emailAddress"] = this.emailAddress;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isAdmin"] = this.isAdmin;
        data["isUpdated"] = this.isUpdated;
        data["userType"] = this.userType;
        return data; 
    }
}

export interface IUserDto {
    id: number;
    username?: string | undefined;
    emailAddress?: string | undefined;
    isEmailConfirmed?: boolean | undefined;
    isAdmin?: boolean | undefined;
    isUpdated?: boolean | undefined;
    userType: UserTypeEnum;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}